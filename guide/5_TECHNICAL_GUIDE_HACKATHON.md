# Hackathon Step by Step Technical Guide

## Overall Flow

We’ll write the provable gameplay first, then test gameplay in a terminal before exporting the gameplay to a WASM package that could be imported by Javascript.

> The frontend will then use the WASM package for gameplay and submit the inputs and outputs of the gameplay to cloud for proof. This is already done for you in this hackathon.

> We then write the on-chain contract that will verify the proof and update the states. This is already done for you in this hackathon.

Don't worry, Spin will provide help along the way.

[![Provable Gameplay Architecture](https://app.eraser.io/workspace/VhcsNlA4uYelufEWe1gi/preview?elements=oGGqigcXhENT2ObWeuMzKg&type=embed)](https://app.eraser.io/workspace/VhcsNlA4uYelufEWe1gi?elements=oGGqigcXhENT2ObWeuMzKg)

#### Why Cloud Proving the Game:

Currently, ZK proving still requires an extremely high amount of computational power. Thus, it is unsuitable for the average computer to generate a proof in a sensible amount of time. We rely on a separate cloud machine to conduct the proof. We believe as ZK technology rapidly evolves, the speed of computation will also increase exponentially and eventually allow for local proving.

Note, the player can always verify the correctness of the proof generated by the cloud prover, just like the on-chain contract will verify the correctness of the proof submitted by the player.

## Start a New Project

[Install Spin SDK](../README.md#installation)

Start a new project:

`npx spin init <required:project_name> --hackathon`

This will create a scaffold for you to work on.

The hackathon scaffold includes 3 components:

-   ZK Provable logic written in Rust
-   A frontend written for you.
-   [Not Include] A contract we already deployed for you

## Writing The Provable Gameplay

We’ll define our provable gameplay in Rust.

Navigate to the folder with the gameplay:

`cd gameplay/provable_game_logic`

You'll want to implement 3 function:

-   initialize_game [optional]
-   step
-   get_game_state

### Initialize the Game: initialize_game(seed: u64)

This is where you can initialize your gameplay. The function takes in a `seed` which could help you generate randomness. Note, please generate randomness purely deterministically from this seed. See an example here: [TODO: fill in example]

### User Inputs: step(input: u64)

The keyboard inputs will be passed as ASCII values, we'll only accept ASCII value from [0-127], inclusive.

See the ASCII table here: https://www.ascii-code.com/

The mouse click values will be passed in as input values from 1000 to 3399, this represent which character is been clicked in the 30x80 matrix.

| input: u64              |    Format    |                   Value |
| :---------------------- | :----------: | ----------------------: |
| 0 - 127 (inclusive)     |    ASCII     |           0 - 127 ASCII |
| 1000 - 3399 (inclusive) | Matrix Index | 0 - 2400 of the display |

### Display: get_game_state() -> String

> 2400 = 30 x 80

This is where you'll display back to the user. The string you return should be less or equal to 2400 in length.
If the size is less than 2400, the rest of the string is padding with `space` until size is 2400.

### [Undert the Hood] Defining the Provable Game Logic

> This part is optional for the hackathon, we already defined a zkmain.rs for you.

Our ZK program takes public inputs, private inputs and produces outputs. We’ll define this program in the `zkmain.rs` file inside the zkmain function.

Here’s an example of such a definition.

```rust
// gameplay/provable_game_logic/src/zkmain.rs
use wasm_bindgen::prelude::*;

use zkwasm_rust_sdk::wasm_input;
use zkwasm_rust_sdk::wasm_output;

#[wasm_bindgen]
pub fn zkmain() -> i64 {
    // specify public inputs
    let a: u64 = unsafe { wasm_input(1) };

    // specify the private inputs
    let b: u64 = unsafe { wasm_input(0) };
    let c: u64 = unsafe { wasm_input(0) };

    unsafe {
        // specify the outputs
        wasm_output(a + b + c);
    }

    0
}
```

We use `wasm_input(0)` to define a private input and `wasm_input(1)` to define a public input.

We use `wasm_output(n)` to define an output.

The rest of the game logic is written in Rust.

The game logic needs to be provide four functions inside the `gameplay.rs`

> Note, these four functions are required to be defined to make Spin to work.

```
// gameplay/provable_game_logic/src/gameplay.rs
...
/* STATEFUL FUNCTIONS This defines the initialization of the game*/
#[wasm_bindgen]
pub fn initialize_game(total_steps: u64, current_position: u64) {
    ...
}

/* STATEFUL FUNCTIONS This is defines the logic when player moves one step/entering one command*/
#[wasm_bindgen]
pub fn step(input: u64) {
    ...
}

/* PURE FUNCTIONS This function returns the game state, but parse into Json, so can be used in Javascript */
#[wasm_bindgen]
pub fn get_game_state() -> String {
    ...
}

/* PURE FUNCTION This function returns the game state, to be used in Rust and Zkmain */
pub fn _get_game_state() -> RustGameState {
    ...
}
```

Here's an [example](https://github.com/m4-team/spin-sdk/blob/sdk/gameplay/provable_game_logic/src/gameplay.rs) of `gameplay.rs` .

> Note, the code is Rust needs be compatible with the `wasm-bindgen` library.

> Note that zkmain is the definition for the ZK program. This is used when we generate the proof. We give the prover inputs, the prover will prove according to the code defined in zkmain.

### Testing the Provable Game Logic

The ZK program only serves the definition of the program. We can write more complex Rust code outside `zkmain.rs` and import to use them. Therefore, sometime we may want to test these Rust codes directly.

Since the ZK program is not compatible with many external Rust crates out there (e.g `termion` for working with terminal interface), we would want to separate our dev dependencies with our zkmain dependencies. We recommended using two separate crate like this:

![image.png](https://eraser.imgix.net/workspaces/VhcsNlA4uYelufEWe1gi/pihQdzIKQ9QhmpC9EQzym8TLbGg2/P6Q-Ite_pPXjPWCxeehzV.png?ixlib=js-3.7.0 "image.png")

In our example from above the `provable_game_logic\` folder and ` testing_cli``\ ` folder are separated. The `provable_game_logic\` folder will contain all our game logic include `zkmain.rs` where as the `testing_cli\` folder will contain our dev dependencies.

```
# Cargo.toml inside provable_game_logic\
[package]
name = "provable_game_logic"
version = "0.1.0"
edition = "2021"

[lib]
name = "provable_game_logic"
path = "src/lib.rs"
crate-type = ["cdylib", "rlib"]

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
primitive-types = { version = "0.12.1", default-features = false }
zkwasm-rust-sdk = { git = "https://github.com/DelphinusLab/zkWasm-rust.git", default-features = true, branch = "main" }
wasm-bindgen = "0.2.92"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
sha2 = "0.10.8"
once_cell = "1.10.0"

[dependencies.web-sys]
version = "0.3.4"
features = ['Document', 'Element', 'HtmlElement', 'Node', 'Window']
```

```
# Cargo.toml inside testing_cli\
[package]
name = "testing_cli"
version = "0.1.0"
edition = "2021"

[dependencies]
termion = "4.0.0"
provable_game_logic = { path = "../provable_game_logic" }
```

So that the dev dependencies are separated.

Following our example, you can test the game logic directly.

[﻿Test the gameplay in terminal](https://github.com/m4-team/zk-sdk/blob/hackathon/README.md#test-gameplay-logic)

You can modify this [﻿file](https://github.com/m4-team/zk-sdk/blob/hackathon/sdk/gameplay/testing_cli/src/main.rs) to apply to your game's needs.

### Exporting the Provable Game Logic

#### Prerequisites

-   Install `wasm-pack` [github.com/rustwasm/wasm-pack](https://github.com/rustwasm/wasm-pack)

There are two places we want to expose our Rust code:

1. Publishing our ZK program image: to tell the prover our ZK program so it can prove it for us.
2. Exporting to frontend: to export the Rust game logic to the frontend, so that the user can interact with the program.

#### Building the ZK program image

```
npx spin build-image --path [path]

[path]: the path to your `gameplay/provable_game_logic` folder
```

#### Publishing your ZK program image/Game to the Cloud Prover

Since we are using a cloud prover, this is easily done by running. We can refer to this image later so ask it to prove an execution of the program.

```
npx spin publish-image --path [path]

[path]: the path to your `gameplay/provable_game_logic` folder
```

If correct, you'll recieve an Image Commitment, save that somewhere to be used next.

#### Create the Game & Upload the ZK Commitment On-Chain

> So far, we can submit a proof on-chain and verify if this proof is correct. However, no where we have specified which ZK program this proof is for.
> A malicious user can always write their own ZK program, generate a correct proof for that program and submit it to our contract.

To prevent this, we need to verify which image the proofs are for.

> For each proof we submit on-chain, they contain an image commitment, Spin Contract will handle verifying it. By default when no image commitment is set, this verification is skipped.

To create a game, open your frontend and click on `Create Game` button.

```
Name: your game's name
Description: a short description of the game
Commitment0-3: copy from when you published the game from previous steps
```

After entering, this should prompt a metamask popup asking you to sign. This will be the transaction that creates the game on-chain.

## Frontend

Spin Team has already built a simple frontend for you. There's no need to modify the frontend.

You just need to run it.

### Run the frontend

Go to `frontend/`

```
npm install && npm run dev
```
