# Hackathon Step by Step Technical Guide

## Overall Flow

We’ll write the provable gameplay first, then test gameplay in a terminal before exporting the gameplay to a WASM package that could be imported by Javascript.

> The frontend will then use the WASM package for gameplay and submit the inputs and outputs of the gameplay to cloud for proof. This is already done for you in this hackathon.

> We then write the on-chain contract that will verify the proof and update the states. This is already done for you in this hackathon.

Don't worry, Spin will provide help along the way.

<img src="https://app.eraser.io/workspace/VhcsNlA4uYelufEWe1gi/preview?elements=oGGqigcXhENT2ObWeuMzKg&type=embed" width="400">

#### Why Cloud Proving the Game:

Currently, ZK proving still requires an extremely high amount of computational power. Thus, it is unsuitable for the average computer to generate a proof in a sensible amount of time. We rely on a separate cloud machine to conduct the proof. We believe as ZK technology rapidly evolves, the speed of computation will also increase exponentially and eventually allow for local proving.

Note, the player can always verify the correctness of the proof generated by the cloud prover, just like the on-chain contract will verify the correctness of the proof submitted by the player.

## Start a New Project

[Install Spin SDK](../README.md#installation)

Start a new project:

`npx spin init <required:project_name> --hackathon`

This will create a scaffold for you to work on.

The hackathon scaffold includes 3 components:

-   ZK Provable logic written in Rust
-   A frontend written for you.
-   [Not Include] A contract we already deployed for you

## Writing The Provable Gameplay

We’ll define our provable gameplay in Rust.

Navigate to the folder with the gameplay:

`cd gameplay/provable_game_logic`

You'll want to implement 3 function:

-   initialize_game [optional]
-   step
-   get_game_state

> `:warning:` these three functions are required to be defined to make Spin to work.

> `:warning:` the code is Rust needs be compatible with the `wasm-bindgen` library. You can test library compatibility in our [dry-run section](./5_TECHNICAL_GUIDE_HACKATHON.md#dry-run-zk-program)

> `:warning:` avoid code that uses floating points.

> `:warning:` avoid code that uses floating points.

> `:warning:` The game should not use any OS or system function, including time, randomness, avoid using external crates

> `:warning:` avoid any asynchrous logics

> Note that zkmain is the definition for the ZK program. This is used when we generate the proof. We give the prover inputs, the prover will prove according to the code defined in zkmain.

---

### Initialize the Game: initialize_game(seed: u64)

This is where you can initialize your gameplay.

The function takes in a `seed` which could help you generate randomness. Note, please generate randomness purely deterministically from this seed.

Here's an example of determinstically generate randomensss:

```Rust
const LCG_M: u64 = 4294967296;
const LCG_A: u64 = 22695477;
const LCG_C: u64 = 1;

#[derive(Debug)]
pub struct LCGRandGen {
    pub seed: u64,
}

// #[wasm_bindgen]
impl LCGRandGen {
    pub fn new(seed: u64) -> Self {
        Self { seed }
    }

    // max is exclusive
    pub fn randint(&mut self, max: u32) -> u32 {
        self.seed = (self.seed * LCG_A + LCG_C) % LCG_M;
        (self.seed % (max as u64)) as u32
    }

    // max is exclusive
    pub fn randint_range(&mut self, min: u32, max: u32) -> u32 {
        min + self.randint(max - min)
    }
}

pub fn randint(seed: u64, max: i32) -> (u64, i32) {
    let seed = (seed * LCG_A + LCG_C) % LCG_M;
    (seed, (seed % (max as u64)) as i32)
    // (self.seed % (max as u64)) as u32
}
```

---

### User Inputs: step(keyCode: u64)

The keyCode are representations of the keys pressed.

See a mapping of the keyCode to the key pressed: **https://www.toptal.com/developers/keycode/table**

---

### Display: get_game_state() -> String

> 2400 = 30 x 80

This is where you'll display back to the user. The string you return should be less or equal to 2400 in length.
If the size is less than 2400, the rest of the string is padding with `space` until size is 2400.

---

### [Undert the Hood] Defining the Provable Game Logic

> This part is optional for the hackathon, we already defined a zkmain.rs for you.

Our ZK program takes public inputs, private inputs and produces outputs. We’ll define this program in the `zkmain.rs` file inside the zkmain function.

Here’s an example of such a definition.

```rust
// gameplay/provable_game_logic/src/zkmain.rs
use wasm_bindgen::prelude::*;

use zkwasm_rust_sdk::wasm_input;
use zkwasm_rust_sdk::wasm_output;

#[wasm_bindgen]
pub fn zkmain() -> i64 {
    // specify public inputs
    let a: u64 = unsafe { wasm_input(1) };

    // specify the private inputs
    let b: u64 = unsafe { wasm_input(0) };
    let c: u64 = unsafe { wasm_input(0) };

    unsafe {
        // specify the outputs
        wasm_output(a + b + c);
    }

    0
}
```

We use `wasm_input(0)` to define a private input and `wasm_input(1)` to define a public input.

We use `wasm_output(n)` to define an output.

The rest of the game logic is written in Rust.

The game logic needs to be provide four functions inside the `gameplay.rs`

Here's an [example](https://github.com/m4-team/spin-sdk/blob/main/sdk/gameplay/provable_game_logic/src/gameplay.rs) of `gameplay.rs` .

## Testing the Provable Game Logic

The ZK program only serves the definition of the program. We can write more complex Rust code outside `zkmain.rs` and import to use them. Therefore, sometime we may want to test these Rust codes directly.

Since the ZK program is not compatible with many external Rust crates out there (e.g `termion` for working with terminal interface), we would want to separate our dev dependencies with our zkmain dependencies. We recommended using two separate crate like this:

<img src="https://eraser.imgix.net/workspaces/VhcsNlA4uYelufEWe1gi/pihQdzIKQ9QhmpC9EQzym8TLbGg2/P6Q-Ite_pPXjPWCxeehzV.png?ixlib=js-3.7.0" width="200">

In our example from above the `provable_game_logic\` folder and ` testing_cli``\ ` folder are separated. The `provable_game_logic\` folder will contain all our game logic include `zkmain.rs` where as the `testing_cli\` folder will contain our dev dependencies.

```
# Cargo.toml inside provable_game_logic\
[package]
name = "provable_game_logic"
version = "0.1.0"
edition = "2021"

[lib]
name = "provable_game_logic"
path = "src/lib.rs"
crate-type = ["cdylib", "rlib"]

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
primitive-types = { version = "0.12.1", default-features = false }
zkwasm-rust-sdk = { git = "https://github.com/DelphinusLab/zkWasm-rust.git", default-features = true, branch = "main" }
wasm-bindgen = "0.2.92"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
sha2 = "0.10.8"
once_cell = "1.10.0"

[dependencies.web-sys]
version = "0.3.4"
features = ['Document', 'Element', 'HtmlElement', 'Node', 'Window']
```

```
# Cargo.toml inside testing_cli\
[package]
name = "testing_cli"
version = "0.1.0"
edition = "2021"

[dependencies]
termion = "4.0.0"
provable_game_logic = { path = "../provable_game_logic" }
```

So that the dev dependencies are separated.

Following our example, you can test the game logic directly.

#### Test the gameplay in terminal

```
cd gameplay
cargo run // This runs the `testing_cli/main.rs`
```

You can modify this `testing_cli/main.rs` to apply to your game's needs.

### Exporting the Provable Game Logic

#### Prerequisites

-   Install `wasm-pack` [github.com/rustwasm/wasm-pack](https://github.com/rustwasm/wasm-pack)

There are two places we want to expose our Rust code:

1. Publishing our ZK program image: to tell the prover our ZK program so it can prove it for us.
2. Exporting to frontend: to export the Rust game logic to the frontend, so that the user can interact with the program.

#### Building the ZK program image

```
npx spin build-image --path [path]

[path]: the path to your `gameplay/provable_game_logic` folder
```

### Dry-Run ZK Program

This dry-runs to help debug any issue might happen during ZK proving, in turn it helps determine if Rust library used are compatible.

#### Prerequisites

-   [Install the zkwasm-cli](https://github.com/DelphinusLab/zkWasm?tab=readme-ov-file#quick-start-with-zkwasm-command-line) (installation might take a while)
-   [Build the WASM file](./5_TECHNICAL_GUIDE_HACKATHON.md#building-the-zk-program-image)

#### Run Dry-Run

```
npx spin dry-run --path [path] --zkwasm [path to zkwasm-cli] --seed [random seed] --keyCode [input1]  --keyCode [input2]

[path]: the path to your `gameplay/provable_game_logic` folder
[zkwasm]: the path to zkwasm-cli, zkwasm-cli should be under `zkwasm/target/debug/zkwasm-cli`
```

seed: the seed you want to force the game
keyCode: the inputs to step(), you can enter multiple keyCode

The dry-run command will output the final state of the game after all inputs has been executed.

## Frontend

Spin Team has already built a simple frontend for you. There's no need to modify the frontend.

You just need to run it.

### Run the frontend

Go to `frontend/`

```
npm install && npm run dev
```

> `Finsh Game`,`Leaderboard`,`Settigns`, `Create Game` won't work until you [publish the game](./5_TECHNICAL_GUIDE_HACKATHON.md#publish-your-game)

> If you face any issue with the UI, just refresh or contact us.

### Force A Seed

The frontend will randomly generate seeds for you, if you want to force a seed:

Modify `NEXT_PUBLIC_GAME_SEED` in `frontend/.env` to force a seed.

### Update After Modification to Image

Everytime after modifying the gameplay, you need to [build](./5_TECHNICAL_GUIDE_HACKATHON.md#building-the-zk-program-image) to reflect changes to the frontend.

## Publish Your Game

It's time to publish your game to the cloud prover, and submit it on-chain.

#### Publishing your ZK program image/Game to the Cloud Prover

```
npx spin publish-image --path [path]

[path]: the path to your `gameplay/provable_game_logic` folder
```

If correct, you'll recieve an Image Commitment and Image Hash, save that somewhere to be used next.

We'll refer to this image ID later so ask it to prove an execution of the program.

> Record down `image_hash` and `image_commitments` and `game_id`. If you have not recorded it down, just run it again.

> If you face `Image not found`, just wait for few seconds and run it again.

#### Tell the Frontend About Your Game

Create and fill in `.env.local` under `frontend/.env.local` with information from the previous `publish-image` step.

If you have not recorded it down, just run it again.

#### Create the Game & Upload the ZK Commitment On-Chain

> About ZK Commitment: A malicious user can always write their own ZK program, generate a correct proof for that program and submit it to our contract. Therefore, we want to identify which ZK program generated that proof.

> For each proof we submit on-chain, they contain an image commitment, Spin Contract will handle verifying it. By default when no image commitment is set, this verification is skipped.

To create a game, open your frontend and click on `Create Game` button.

```
Name: your game's name
Description: a short description of the game
Commitment0-3: copy from when you published the game from previous `publish-image` steps
```

After entering, this should prompt a metamask popup asking you to sign. This will be the transaction that creates the game on-chain.

Voilà! You have create a ZK game on-chain. Now let's play it!

## Playing the Game

Play the game, and when you finish playing, click `Finish & Prove Game`, this will generate a proof and ask you to submit it on-chain. (This will take a while, 1 minute or 2).

Once the game is proved and submitted on-chain, you can check out `Leaderboard`.
