# Step by Step Technical Guide

## Overall Flow

We’ll write the provable gameplay first, then test gameplay in a terminal before exporting the gameplay to a WASM package that could be imported by Javascript.

The frontend will then use the WASM package for gameplay and submit the inputs and outputs of the gameplay to cloud for proof.

We then write the on-chain contract that will verify the proof and update the states.

Don't worry, Spin will provide help along the way.

[![Provable Gameplay Architecture](https://app.eraser.io/workspace/VhcsNlA4uYelufEWe1gi/preview?elements=oGGqigcXhENT2ObWeuMzKg&type=embed)](https://app.eraser.io/workspace/VhcsNlA4uYelufEWe1gi?elements=oGGqigcXhENT2ObWeuMzKg)

#### Why Cloud Proving the Game:

Currently, ZK proving still requires an extremely high amount of computational power. Thus, it is unsuitable for the average computer to generate a proof in a sensible amount of time. We rely on a separate cloud machine to conduct the proof. We believe as ZK technology rapidly evolves, the speed of computation will also increase exponentially and eventually allow for local proving.

Note, the player can always verify the correctness of the proof generated by the cloud prover, just like the on-chain contract will verify the correctness of the proof submitted by the player.

## Start a New Project

[﻿﻿Install Spin SDK](../README.md#installation)

(https://github.com/rustwasm/wasm-pack)

Start a new project:

`npx spin-m4 init <required:folder_name>`

This will create a scaffold for you to work on.

The scaffold includes 3 components:

-   ZK Provable logic written in Rust
-   A frontend example, a simple grid walking game.
-   Solidity contract example, works together with the grid walking game.

## Quick Demo Before Getting Started

Before diving into each components, let's quickly build and run an end-to-end example to see the game in action.

We'll make a grid walking game, a player walks in an 1x10 grid.

#### Start the project

```
npx spin-m4 init demo
```

#### Build the Image

```
cd demo
npx spin-m4 build-image --path gameplay/provable_game_logic/
```

#### Run the frontend

Rename `demo/frontend/template.env` to `demo/frontend/.env`

```
cd demo/frontend
npm install
npm run dev
```

## Testing the Gameplay in Terminal

Our scaffold already provide a running example of the game. To run it:

Go to directory `cd gameplay/`

Run

```bash
cargo run
```

> Make sure you have already installed Rust

#### Under the hood

This run the Rust file under `gameplay/testing_cli/src/main.rs`.

This file is just a terminal interface that displays the current game states and pass in user inputs.

Modify the file `gameplay/testing_cli/src/main.rs` as needed when write your game out.

## Writing The Provable Gameplay

We’ll define our provable gameplay in Rust.

Navigate to the folder with the gameplay:

`cd gameplay/provable_game_logic`

### Defining the Provable Game Logic

Spin currently only support a simple game architecture by utilizing 3 functions: `initialize_game`, `step`, `get_game_state`.

`initialize_game` is the initialization fo the game, this might be starting of a game session and use on-chain data to initialize the game.

`step` is when the player performs an action and moves to the next step of the game. Step should be state mutating.

`get_game_state` is a non-state-changing function that gets the current state. This might be called after each step.

#### 1. Define your game's inputs and outputs

Go to file `gameplay/provable_game_logic/src/definition.rs`

Update the definitions for `SpinGameInitArgs` & `SpinGameIntermediateStates` to your game's need. All data types needs to be u64 for now.

> `SpinGameInitArgs` is for initialization of the game, this is passed to `initialize_game` when the game starts.

> `SpinGameIntermediateStates` is the output of the game at each step. This is the output of `get_game_state`.

#### 2. Update the ZK main [this step will be automated in the future]

Go to file `gameplay/export/src/zkmain.rs`

zkmain.rs is the definition for the ZK program. This is used when we generate the proof. We give the prover inputs, the prover will prove according to the code defined in zkmain.

Our ZK program takes public inputs, private inputs and produces outputs. We’ll define this program in the `zkmain.rs` file inside the zkmain function.

We use `wasm_input(0)` to define a private input and `wasm_input(1)` to define a public input.

We use `wasm_output(n)` to define an output.

Now, update `zkmain.rs` accoridng to your game's definition. The initialization args should be public inputs while, all the steps should be private inputs.

Here’s an example of such a definition.

```rust
// gameplay/export/src/zkmain.rs
use wasm_bindgen::prelude::*;

use zkwasm_rust_sdk::wasm_input;
use zkwasm_rust_sdk::wasm_output;

#[wasm_bindgen]
pub fn zkmain() -> i64 {
    // specify public inputs
    let a: u64 = unsafe { wasm_input(1) };

    // specify the private inputs
    let b: u64 = unsafe { wasm_input(0) };
    let c: u64 = unsafe { wasm_input(0) };

    unsafe {
        // specify the outputs
        wasm_output(a + b + c);
    }

    0
}
```

#### 3. Write the game logic

Go to file `gameplay/provable_game_logic/src/gameplay.rs`

Implement the trait `SpinGameTrait` for `SpinGame`; this where you'll define the gameplay by implement the 3 functions: `initialize_game`, `step`, `get_game_state`.

### Testing the Provable Game Logic

When writing code, we always want to test and play with it as a good software engineering practice. So to test the ZK program, we found the following two ways:

### Dry-Run of the ZK Program

@TODO

We can test the `zkmain.rs` we defined directly with some inputs. With a dry-run! We can run the ZK program and see its outputs. We can also set debugging messages inside our program and observe them as printouts of the dry-run.

#### Prerequisites

-   [﻿Install the zkwasm-cli](https://github.com/DelphinusLab/zkWasm](github.com/DelphinusLab/zkWasm)

#### _Writing Debug For Dry-Run_

You can add logs in help debug, these logs will be printed out when dry-run.

```
// zkmain.rs
use wasm_bindgen::prelude::*;

use zkwasm_rust_sdk::wasm_input;
use zkwasm_rust_sdk::wasm_output;

#[wasm_bindgen]
pub fn zkmain() -> i64 {
    // specify public inputs
    let a: u64 = unsafe { wasm_input(1) };

    // specify the private inputs
    let b: u64 = unsafe { wasm_input(0) };
    let c: u64 = unsafe { wasm_input(0) };

    unsafe {
        // debug message that will show up during dry-run
        zkwasm_rust_sdk::dbg!("a+b+c: {}\n", a+b+c);
        // specify the outputs
        wasm_output(a + b + c);
    }

    0
}
```

### Exporting the Provable Game Logic

#### Prerequisites

-   Install `wasm-pack` [﻿github.com/rustwasm/wasm-pack](https://github.com/rustwasm/wasm-pack)

There are two places we want to expose our Rust code:

1. Publishing our ZK program image: to tell the prover our ZK program so it can prove it for us.
2. Exporting to frontend: to export the Rust game logic to the frontend, so that the user can interact with the program.

> To understand why we want to do the second step, let’s think about how the player interacts with the game.
> Typically a game involves a player doing some action and receiving feedback. This may be clicking on an attack button and then it fights with a monster, the player then loses some health for example. Remember we defined this gameplay logic in Rust. We can’t directly call Rust code in Javascript, but we can use the WASM package generated. WASM packages can be directly imported into Javascript.

#### Build the ZK program image

This step will build the Rust code into a WASM image and also a Javascript package called `spin` that is a wrapper of the WASM image. The `spin` package can be used in the frontend.

```
npx spin-m4 build-image --path [path]

[path]: the path to your `gameplay/provable_game_logic` folder
```

After building, you can find the two exports:

The Javascript package is located at `gameplay/export/spinjs/`

The WASM for proving is located at `gameplay/export/wasm/`

#### Publishing our ZK program image

This step will publish the image to a cloud prover. Currently the cloud prover is freely provided by Spin and no credential is needed.

Since we are using a cloud prover, this is easily done by running. We can refer to this image later so ask it to prove an execution of the program.

```
npx spin-m4 publish-image --path [path]

[path]: the path of your `gameplay/provable_game_logic` folder
```

If correct, you'll recieve an Image Commitment and Image Hash, save that somewhere to be used next.

We'll refer to this image ID later so ask it to prove an execution of the program.

> Record down `image_hash` and `image_commitments` and `game_id`. If you have not recorded it down, just run it again.

> If you face `Image not found`, just wait for few seconds and run it again.

## Writing On-Chain Contract

##### Permanent vs. Ephemeral

> Remember the gameplay logic are separate into two parts: the fast ephemeral off-chain ZK
> provable part, and the slow but permanent on-chain part.
> Depends on the game itself, you can decide what should be on-chain what stays off-chain.
> As a rule-of-thumb:
> On-Chain: Permanent data, needs to referred back later, Important data, more expensive and slower to write to.
> Off-Chain: Ephemeral data, data not visible unless using a DA(Data Availability) solution, cheaper and faster.

[![on chain vs off chain data](https://app.eraser.io/workspace/VhcsNlA4uYelufEWe1gi/preview?elements=CtTSv0adtV60FBSXiIsfsQ&type=embed)](https://app.eraser.io/workspace/VhcsNlA4uYelufEWe1gi?elements=CtTSv0adtV60FBSXiIsfsQ)

Spin has provided an abstract contract that you can implement, which can handle verification flow and updating verification configs.

Check out the [﻿SpinContract here](https://github.com/m4-team/zk-sdk/blob/hackathon/sdk/onchain/contracts/SpinContract.sol).

#### _Implement the Spin Contract_

````

//SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./SpinContract.sol";

contract GameContract is SpinContract {
// PASS IN THE CONSTRUCTOR ARGUMENTS
constructor(address verifier_address) SpinContract(verifier_address) {}

    ...

    // Settle a verified proof
    function settle(uint256[][] calldata instances) internal override {
        // parse the input and output of the zkprogram
        ZKInput memory zk_input = ZKInput(uint64(instances[0][0]), uint64(instances[0][1]));

        ZKOutput memory zk_output = ZKOutput(uint64(instances[0][2]), uint64(instances[0][3]));

        require(
            zk_input.start_total_steps == total_steps && zk_input.start_position == current_position,
            "Invalid start state"
        );

        total_steps = zk_output.end_total_steps;
        current_position = zk_output.end_position;

        emit UpdateState(
            zk_input.start_total_steps, zk_input.start_position, zk_output.end_total_steps, zk_output.end_position
        );
    }

}

```

Here's an example in practice using our Grid Walking game:

```

//SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./SpinContract.sol";

contract GameContract is SpinContract {
/_ Trustless Application Settlement Template _/
constructor(address verifier_address) SpinContract(verifier_address) {}

    /* Application On-chain Business Logic */

    // Here we use a simple example where the player can move a cursor in a 1-D space and
    // keep track of the total steps.

    uint64 public total_steps;
    uint64 public current_position;

    event UpdateState(
        uint64 previous_total_steps, uint64 previous_position, uint64 total_steps, uint64 current_position
    );

    // Get the current state of the game contract
    function getStates() external view returns (uint64, uint64) {
        return (total_steps, current_position);
    }

    struct ZKInput {
        uint64 start_total_steps;
        uint64 start_position;
    }

    struct ZKOutput {
        uint64 end_total_steps;
        uint64 end_position;
    }

    // Settle a verified proof
    function settle(uint256[][] calldata instances) internal override {
        ZKInput memory zk_input = ZKInput(uint64(instances[0][0]), uint64(instances[0][1]));

        ZKOutput memory zk_output = ZKOutput(uint64(instances[0][2]), uint64(instances[0][3]));

        require(
            zk_input.start_total_steps == total_steps && zk_input.start_position == current_position,
            "Invalid start state"
        );

        total_steps = zk_output.end_total_steps;
        current_position = zk_output.end_position;

        emit UpdateState(
            zk_input.start_total_steps, zk_input.start_position, zk_output.end_total_steps, zk_output.end_position
        );
    }

    function DEV_ONLY_setStates(uint64 _total_steps, uint64 _current_position) external onlyOwner {
        total_steps = _total_steps;
        current_position = _current_position;
    }

}

````

Spin Contract will handle the verifying and give a callback with the zkprogram's input and outputs through the `settle()` function.

Your core business logic contract can update the states accordingly.

For example, if the ZK program takes in starting score, and outputs an ending score, your on-chain contract may need to check if the player currently indeed has the starting score on-chain and update that with the ending score.

#### Decoding the Public Inputs and Outputs

You can find the public inputs and outputs inside the parameter instance together.
The instance is an array of un-signed integers. The public inputs are ordered first in the array then all the outputs. The inputs and outputs should follows the same order as in your `ZKmain.rs`.

#### Verify the Correct ZK Image On-Chain

> So far, we can submit a proof on-chain and verify if this proof is correct. However, no where we have specified which ZK program this proof is for.
> A malicious user can always write their own ZK program, generate a correct proof for that program and submit it to our contract.

To prevent this, we need to verify which image the proofs are for.

This is done by [﻿setting a verifier image commitment](https://github.com/m4-team/zk-sdk/blob/f5f777611628b8e2d026409901ea8c2d1b1a40fc/sdk/onchain/contracts/SpinContract.sol#L58). We obtain the image commitment when publishing the image.

> For each proof we submit on-chain, they contain an image commitment, Spin Contract will handle verifying it. By default when no image commitment is set, this verification is skipped.

## Frontend

Now we have our gameplay ready, on-chain and off-chain.

Let’s build the UI and integrate all these things together.

Fill in the .env, rename `frontend/template.env` to `frontend/.env`

We have provided a local package in Javascript called Spin, this class serves as a template and can help import the WASM packages and generate the proof through the cloud prover.

The package is generated upon building the WASM image and is located in `gameplay/export/spinjs`

> You can install this package locally using `file:...` format in NPM. For example using [﻿npm](https://github.com/m4-team/spin-sdk/blob/main/sdk/frontend/package.json#L21).

Check out the complete [﻿demo code here](https://github.com/m4-team/spin-sdk/tree/main/sdk/frontend).

You can then [﻿submit the proof on-chain](https://github.com/m4-team/spin-sdk/blob/main/sdk/frontend/src/App.tsx#L123-L131) however you like.

## Put Everything Together

For a full-fledged demo game, see our game Cats vs. Dogs
